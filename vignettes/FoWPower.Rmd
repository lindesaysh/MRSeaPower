---
title: "Falls of Warness"
author: "Lindesay Scott-Hayward"
date: "11 August 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Real Data: Falls of Warness

```{r fow, echo=FALSE}
devtools::load_all(pkg = '../../../../Packages/MRSea package/MRSea')
devtools::load_all(pkg = '../../MRSeaPower')
data(fowshco)
```

### Fit Initial Model
```{r fowinitglm}
init_glm<-glm(response ~  as.factor(TideState) + WindStrength + SeaState + SimpPrecipitation + CloudCover + Depth + offset(log(areatime)), data=dat, family=quasipoisson)
```


### Runs Test Check

Data generated under the null hypothesis of the runs test; independence and with no change induced at this stage.

```{r fownoise}
nsim<-500
d<-as.numeric(summary(init_glm)$dispersion)
newdat<-generateNoise(nsim, fitted(init_glm), family='poisson', d=d)
```

`r nsim` sets of noisy data are simulated from the model using an overdispersed Poisson distribution where $\hat{\phi} = $ `r round(summary(init_glm)$dispersion)`.

```{r critvalsfow, cache=T, fig.cap='Figure showing the distribution of test statistics from a runs test. The red lines show the lower 2.5% and upper 97.5% critical values of the empirical distribution and the blue lines are from the Normal ($N(0,1)$) distribution.'}
empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                 model = init_glm, data = dat, plot=TRUE, 
                                 returnDist = TRUE, dots=FALSE)
```

Evaluate the runs test using the empirical distribution to determine if the data are independent
```{r runsacffow}
runs.test(residuals(init_glm, type='pearson'), critvals = empdistribution)
acf(residuals(init_glm, type='pearson'))
```

The residuals are not considered independent so for the power analysis, the data will be generated as correlated.

### Data Generation

Data are generated with no change but with the same dispersion and correlation as the original data so that the data generation process can be checked.

```{r cordatfow, cache=TRUE}
corrs<-getCorrelationMat(dat$blockid, dat$response, dots=FALSE)
newdatcor<-generateIC(data = dat, corrs = corrs, panels = 'blockid', newdata = newdat, nsim = nsim, dots = FALSE)
```

The generated data are consistent with the original data:

#### Mean
```{r}
hist(apply(newdat, 2, mean), main='', xlab='mean(response)')
abline(v=mean(dat$response), col='red', lwd=2, lty=3)
```

#### Variance
```{r}
hist(apply(newdat, 2, var), main='', xlab='var(response)')
abline(v=var(dat$response), col='red', lwd=2, lty=3)
```

#### Correlation

```{r}
par(mfrow=c(1,2))
acf(dat$response, main='Data')
acf(newdatcor[,50], main='Sim Data')
```

#### Check the dispersion parameter

```{r}
fowsim_glm<-update(init_glm, newdat[,1] ~ .)
summary(fowsim_glm)$dispersion
```

### Power Analysis

Generate data for power analysis with impact of 10\%

```{r powerdatgen, cache=TRUE}
nsim=500
impdata<-genOverallchangeData(log(0.9), init_glm, data = dat, panels = 'newbidNum')
newdat<-generateNoise(nsim, impdata$truth, family='poisson', d=d)
newdatcor<-generateIC(data = impdata, corrs = rbind(corrs, corrs), panels = 'panels', newdata = newdat, nsim = nsim, dots = FALSE)
```

Update the initial model to include the eventphase term, indicating overall change.

```{r}
fowsim_glm<-glm(newdatcor[,1] ~  as.factor(TideState) + WindStrength + SeaState + SimpPrecipitation + CloudCover + Depth  + as.factor(eventphase) + offset(log(areatime)), data=impdata, family=quasipoisson)
```

Using the simulated data with noise but no correlation, estimate the new values for the empirical distribution for the runs test.

```{r empdistpower, cache=TRUE}
# make sure that the independent data is used to get the null distribution
empdistpower<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                 model = fowsim_glm, data = impdata, plot=TRUE, 
                                 returnDist = TRUE, dots=FALSE)
```


```{r, powerouta, cache=TRUE}
runspowsim_out<-runsPowerSim(newdatcor, fowsim_glm, empdistpower, nsim, powercoefid = length(coef(fowsim_glm)))
  
apply(runspowsim_out$rawrob, 2, sum)/nsim
  
(length(which(runspowsim_out$imppvals[,1]<=0.05))/nsim)*100
(length(which(runspowsim_out$imppvals[,2]<=0.05))/nsim)*100

```

```{r poweroutfow, cache=TRUE}
predictdata<-rbind(data.frame(griddata, TideState=1, WindStrength=0, SeaState=0, SimpPrecipitation='SHOWERS', CloudCover=0, areatime=1, eventphase=0), data.frame(griddata, TideState=1, WindStrength=0, SeaState=0, SimpPrecipitation='SHOWERS', CloudCover=0,areatime=1, eventphase=1))

powerout<-powerSimOverallChange(newdatcor, fowsim_glm, empdistpower, nsim=100, powercoefid=length(coef(fowsim_glm)), predictionGrid=predictdata, g2k=NULL, splineParams=NULL, sigdif=TRUE, n.boot=500)

```

```{r}
(length(which(powerout$imppvals<=0.05))/nsim)*100
```

```{r}
plotdata<-plot.sigdiff(powerout, predictdata[predictdata$eventphase==0,c('x.pos', 'y.pos')], tailed='two', error.rate = 0.05, family=FALSE)
plotdata
```

