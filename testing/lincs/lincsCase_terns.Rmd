---
title: 'Lincs Power Analysis: Auks'
author: "Lindesay Scott-Hayward"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig=TRUE, dev='png', warning=FALSE, message=FALSE)
```


```{r}
devtools::load_all(pkg='C://MarineScotlandPower/MRSeaPower')
devtools::load_all(pkg='C://MarineScotlandPower/MRSea/MRSea')
setwd("C:/MarineScotlandPower/MRSeaPower/testing/lincs/")

require(fields)
require(splines)
require(mgcv)
require(MRSea)
require(dplyr)
require(ggplot2)
require(RColorBrewer)
breaks<-ticks<-c(0, 0.2, 0.4, 0.6, 0.8, 1, 10, 25)
mypalette<-rev(brewer.pal(length (ticks)-1,"Spectral"))
require(sp)
require(raster)
require(splancs)
```

```{r}
lincs<-read.csv('D:\\lindesay\\MarScoPower\\finalreportdata\\phase1Data.csv')

lincs$response<-lincs$TERN
lincs$foldid<-getCVids(lincs, 10, 'line_id')
```

remove data points > 300 animals
```{r}
#lincs<-lincs[-which(lincs$response>170),]
lincs<-arrange(lincs, line_id, segment)
lincs$panels<-as.numeric(lincs$line_id)
```

```{r salsa1d, cache=TRUE}
initialModel<-glm(response ~ 1 + offset(log(area)), data=lincs, family=quasipoisson)

factorlist<-NULL
varlist<-c('depth', 'month')

salsa1dlist<-list(fitnessMeasure='QAIC', minKnots_1d = c(1,1), maxKnots_1d=c(5,5), startKnots_1d = c(1,1), degree=c(2,2), maxIterations=100, gaps=c(0,0))

salsa1dout<-runSALSA1D_withremoval(initialModel, salsa1dlist, varlist, factorlist, varlist_cyclicSplines = c('month'), splineParams = NULL, datain=lincs, suppress.printout = TRUE)

salsa1dout$bestModel$splineParams<-salsa1dout$splineParams

bestModel1D<-make.gamMRSea(salsa1dout$bestModel, panelid = lincs$panels, splineParams = salsa1dout$splineParams)

```

```{r}
sink()
sink()
```


```{r}
summary(salsa1dout$bestModel)
```

```{r}
anova(salsa1dout$bestModel)
```


```{r}
par(mfrow=c(1,2))
runPartialPlots(bestModel1D, data = lincs, factorlist.in = factorlist, varlist.in = varlist, showKnots = T)
```


```{r salsa2d, cache=TRUE}
knotgrid<-getKnotgrid(cbind(lincs$x.pos, lincs$y.pos))
distMats<-makeDists(cbind(lincs$x.pos, lincs$y.pos), na.omit(knotgrid))
# choose sequence of radii
r_seq<-getRadiiChoices(8, distMats$dataDist)

salsa2dlist<-list(fitnessMeasure = 'QAIC', knotgrid = knotgrid, knotdim = c(100, 100),  startKnots=6, minKnots=2, maxKnots=20, r_seq=r_seq, gap=0)


salsa2dOutput<-runSALSA2D(bestModel1D, salsa2dlist, d2k=distMats$dataDist, k2k=distMats$knotDist, splineParams=NULL, tol=0, chooserad=F, panels=NULL, suppress.printout=TRUE)

bestModel<-make.gamMRSea(salsa2dOutput$bestModel, panelid = as.numeric(lincs$line_id), splineParams = salsa2dOutput$splineParams, varshortnames = varlist, gamMRSea=TRUE)

```

```{r}

par(mfrow=c(1,2))
quilt.plot(lincs$x.pos, lincs$y.pos, lincs$response, asp=1, nrow=80, ncol=80)
quilt.plot(lincs$x.pos, lincs$y.pos, fitted(bestModel), asp=1)

```

```{r}
#save(bestModel, file='D:/lindesay/MarScoPower/finalreportdata/lincsAUKmodel.RData', compress='bzip2')

#load('D:/lindesay/MarScoPower/finalreportdata/lincsAUKmodel.RData')
```


#### check for correlation:

```{r corcheck, cache=TRUE}
nsim<-500
d<-as.numeric(summary(bestModel)$dispersion)
newdat<-generateNoise(nsim, fitted(bestModel), family='poisson', d=d)

empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat,   model = bestModel, data = lincs, plot=TRUE,   returnDist = TRUE, dots=FALSE)

runs.test(residuals(bestModel, type='pearson'), critvals = empdistribution)
acf(residuals(bestModel, type='pearson'))

#lincs$panels<-as.numeric(lincs$line_id)
corrs<-getCorrelationMat(lincs$panels, lincs$response, dots=FALSE)
newdatcor<-generateIC(data = lincs, corrs = corrs, panels = 'panels', newdata = newdat, nsim = nsim, dots = TRUE)

```

### check data generation process
```{r}
plotMean(bestModel, newdatcor)

```

```{r}
plotVariance(bestModel, newdatcor)
```

```{r}
# par(mfrow=c(2,2))
# acf(lincs$response, main='Data')
# acf(newdat[,1], main='sim data')
# acf(residuals(bestModel, type='pearson'), main='original model residuals')
# acf(residuals(update(bestModel, newdat[,1] ~ .), type='pearson'), main='sim model residuals')

par(mfrow=c(2,2))
runACF(lincs$panels, model = lincs$response)
runACF(lincs$panels, model = newdatcor[,1])
runACF(lincs$panels, model = bestModel)
runACF(lincs$panels, model = update(bestModel, newdatcor[,1]~.))



par(mfrow=c(2,2))
acf(lincs$response, main='Data')
acf(newdatcor[,10], main='sim data')
acf(residuals(bestModel, type='pearson'), main='original model residuals')
acf(residuals(update(bestModel, newdatcor[,10] ~ .), type='pearson'), main='sim model residuals')
```

```{r}
par(mfrow=c(2,2))
quilt.plot(lincs$x.pos, lincs$y.pos, lincs$response, main='Original Data')
quilt.plot(lincs$x.pos, lincs$y.pos, fitted(bestModel), main='Fitted Values')
quilt.plot(lincs$x.pos, lincs$y.pos, newdat[,1], main='Simulated Data Example')
quilt.plot(lincs$x.pos, lincs$y.pos, apply(newdat, 1, mean), main='Mean Simulated Data')

```

```{r}
par(mfrow=c(1,1))
quilt.plot(lincs$x.pos, lincs$y.pos, apply(newdat, 1, mean) - fitted(bestModel))
```

# power analysis

### Generate impact data
```{r}
nsim=500
truebeta<-log(0.5)
impdata.auk<-genOverallchangeData(changecoef.link = truebeta, model = bestModel, data = lincs,panels = "panels")
```

```{r}
t<-group_by(impdata.auk, eventphase)%>%
  summarise(sum=sum(truth), mean=mean(truth), n=n())
t
```

```{r}

bef<-impdata.auk[impdata.auk$eventphase==0,]
aft<-impdata.auk[impdata.auk$eventphase==1,]

spdf1<- SpatialPointsDataFrame( data.frame( x = bef$x.pos , y = bef$y.pos ) , data = data.frame( z = bef$truth) )
e <- extent( spdf1 )
ratio <- ( e@xmax - e@xmin ) / ( e@ymax - e@ymin )
r <- raster( nrows = 60 , ncols = floor( 60 * ratio ) , ext = extent(spdf1) )
rf <- rasterize( spdf1 , r , field = "z" , fun= mean)
rdf1 <- data.frame( rasterToPoints( rf ), evph=0 )   

spdf2<- SpatialPointsDataFrame( data.frame( x = aft$x.pos , y = aft$y.pos ) , data = data.frame( z = aft$truth) )
e <- extent( spdf2 )
ratio <- ( e@xmax - e@xmin ) / ( e@ymax - e@ymin )
r <- raster( nrows = 60 , ncols = floor( 60 * ratio ) , ext = extent(spdf2) )
rf <- rasterize( spdf2 , r , field = "z" , fun= mean)
rdf2 <- data.frame( rasterToPoints( rf ), evph=1 ) 

rdf<-rbind(rdf1, rdf2)
names(rdf)[3]<-'Mean.count'

pct.change<-((rdf$Mean.count[rdf$evph==1] - rdf$Mean.count[rdf$evph==0])/rdf$Mean.count[rdf$evph==0]
)*100

ggplot( NULL ) + geom_raster( data = rdf1 , aes( x , y , fill = pct.change ) ) + scale_fill_gradientn(colours=mypalette, values = breaks,space = "Lab", na.value = "grey50", guide = "colourbar") + theme_bw()

```



```{r}
newdata.auk.imp<-generateNoise(nsim, impdata.auk$truth, family='poisson', d=summary(bestModel)$dispersion)
newdatcor.auk.imp<-generateIC(data = impdata.auk, corrs = rbind(corrs,corrs), panels = 'panels.1', newdata = newdata.auk.imp, nsim = nsim, dots = FALSE)

```

```{r}
bestModel$splineParams[[1]]$dist<-rbind(bestModel$splineParams[[1]]$dist, bestModel$splineParams[[1]]$dist)
auksim_glm<-update(bestModel, newdatcor.auk.imp[,1]~. + eventphase, data=impdata.auk)
auksim_glm$panels<-impdata.auk$panels.1

```


make sure that the independent data is used to get the null distribution
```{r warning=FALSE, message=FALSE}
empdistpower.auk<-getRunsCritVals(n.sim = nsim, simData=newdatcor.auk.imp, 
                                  model = auksim_glm, data = impdata.auk, plot=FALSE,  returnDist = TRUE, dots=FALSE)
```


```{r}
preddata<-read.csv('../../data/lincspreddata.csv')

# make predictions for month 10 - month with highest estimated density (from month partial plot)
predictdata<-rbind(data.frame(preddata, month=6, area=1, eventphase=0), data.frame(preddata, month=6, area=1, eventphase=1))

g2k<-makeDists(cbind(predictdata$x.pos, predictdata$y.pos), knotcoords = na.omit(bestModel$splineParams[[1]]$knotgrid), knotmat = FALSE)$dataDist


```


```{r aukpower, cache=TRUE}
nsim=50
powerout.auk.oc<-powerSimPll(newdatcor.auk.imp, auksim_glm, empdistpower.auk, nsim=nsim, powercoefid=length(coef(auksim_glm)), predictionGrid=predictdata, g2k=g2k, splineParams=auksim_glm$splineParams, sigdif=TRUE, n.boot=500, nCores = 6)
```

```{r}
save(powerout.auk.oc, file='../FinalReportCode/powerout.lincsauk.oc.RData', compress = 'bzip2')
```


```{r auknull, cache=TRUE}
null.output.auk.oc<-pval.coverage.null(newdat.ind = newdata.auk.imp, newdat.corr = NULL, model = auksim_glm, nsim = nsim, powercoefid = length(coef(auksim_glm)))

```

```{r}
save(null.output.auk.oc, file='../FinalReportCode/null.output.lincsauk.oc.RData', compress = 'bzip2')

```




```{r}
summary(powerout.auk.oc, null.output.auk.oc, truebeta=truebeta)
```


```{r}
powerPlot(powerout.auk.oc)

```

```{r}
plot.preds(powerout.auk.oc)
```

```{r}
plot.diffs(powerout.auk.oc)
```

```{r}
plot.sigdiff(powerout.auk.oc, coordinates = predictdata[predictdata$eventphase==0,c('x.pos', 'y.pos')], tailed='two', error.rate = 0.05)
```

```{r}
plot.sigdiff(powerout.auk.oc, coordinates = predictdata[predictdata$eventphase==0,c('x.pos', 'y.pos')], tailed='two', error.rate = 0.05, adjustment='sidak')
```

```{r}
plot.sigdiff(powerout.auk.oc, coordinates = predictdata[predictdata$eventphase==0,c('x.pos', 'y.pos')], tailed='two', error.rate = 0.05, adjustment='bonferroni')
```


# Power analysis: 25% decline

### Generate impact data
```{r}
nsim=500
truebeta<-log(0.75)
impdata.auk<-genOverallchangeData(changecoef.link = truebeta, model = bestModel, data = lincs)
```

```{r}
t<-group_by(impdata.auk, eventphase)%>%
  summarise(sum=sum(truth), mean=mean(truth), n=n())
t
```

```{r}
newdata.auk.imp<-generateNoise(nsim, impdata.auk$truth, family='poisson', d=summary(bestModel)$dispersion)
```

```{r}
auksim_glm<-update(bestModel, newdata.auk.imp[,1]~. + eventphase, data=impdata.auk)
auksim_glm$panels<-impdata.auk$panels
```


make sure that the independent data is used to get the null distribution
```{r warning=FALSE, message=FALSE}
empdistpower.auk<-getRunsCritVals(n.sim = nsim, simData=newdata.auk.imp, 
                                  model = auksim_glm, data = impdata.auk, plot=FALSE,  returnDist = TRUE, dots=FALSE)

```


```{r aukpower25, cache=TRUE}
nsim=400
powerout.auk.oc25<-powerSimPll(newdata.auk.imp, auksim_glm, empdistpower.auk, nsim=nsim, powercoefid=length(coef(auksim_glm)), predictionGrid=predictdata, g2k=g2k, splineParams=auksim_glm$splineParams, sigdif=TRUE, n.boot=500, nCores = 6)
```

```{r}
save(powerout.auk.oc25, file='../FinalReportCode/powerout.lincsauk.oc25.RData', compress = 'bzip2')
```


```{r auknull25, cache=TRUE}
null.output.auk.oc25<-pval.coverage.null(newdat.ind = newdata.auk.imp, newdat.corr = NULL, model = auksim_glm, nsim = nsim, powercoefid = length(coef(auksim_glm)))

```

```{r}
save(null.output.auk.oc25, file='../FinalReportCode/null.output.lincsauk.oc25.RData', compress = 'bzip2')

```


```{r}
summary(powerout.auk.oc, null.output.auk.oc, truebeta=truebeta)
```


```{r}
powerPlot(powerout.auk.oc)

```

```{r}
plot.preds(powerout.auk.oc)
```

```{r}
plot.diffs(powerout.auk.oc)
```

```{r}
plot.sigdiff(powerout.auk.oc, coordinates = predictdata[predictdata$eventphase==0,c('x.pos', 'y.pos')], tailed='two', error.rate = 0.05)
```

```{r}
plot.sigdiff(powerout.auk.oc, coordinates = predictdata[predictdata$eventphase==0,c('x.pos', 'y.pos')], tailed='two', error.rate = 0.05, adjustment='sidak')
```

```{r}
plot.sigdiff(powerout.auk.oc, coordinates = predictdata[predictdata$eventphase==0,c('x.pos', 'y.pos')], tailed='two', error.rate = 0.05, adjustment='bonferroni')
```
