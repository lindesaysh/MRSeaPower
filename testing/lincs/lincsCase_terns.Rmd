---
title: 'Lincs Power Analysis: Auks'
author: "Lindesay Scott-Hayward"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig=TRUE, dev='png', warning=FALSE, message=FALSE)
```


```{r}
devtools::load_all(pkg='C://MarineScotlandPower/MRSeaPower')
devtools::load_all(pkg='C://MarineScotlandPower/MRSea/MRSea')
setwd("C:/MarineScotlandPower/MRSeaPower/testing/lincs/")

require(fields)
require(splines)
require(mgcv)
require(MRSea)
require(dplyr)
require(ggplot2)
require(RColorBrewer)
breaks<-ticks<-c(0, 0.2, 0.4, 0.6, 0.8, 1, 10, 25)
mypalette<-rev(brewer.pal(length (ticks)-1,"Spectral"))
require(sp)
require(raster)
require(splancs)
```

```{r loaddata}
lincsfull<-read.csv('D:\\lindesay\\MarScoPower\\finalreportdata\\phase1Data.csv')
load('D:\\lindesay\\MarScoPower\\finalreportdata\\HiDef2016_pred_grid.rdata')
predbnd<-pred_grid[chull(pred_grid$x, pred_grid$y),c('x', 'y')]

lincs<-lincsfull[which(inout(pts = cbind(lincsfull$x.pos, lincsfull$y.pos), poly = predbnd)==T),]

```

Subset the original data to just the region of the prediction grid
```{r}
quilt.plot(lincs$x.pos, lincs$y.pos, lincs$AUK)
```

remove data points > 200 animals

```{r aukdat}
lincs$response<-lincs$AUK
lincs<-lincs[which(lincs$AUK<200),]
lincs$foldid<-getCVids(lincs, 10, 'line_id')
#lincs<-arrange(lincs, date, segment)
```


```{r arrangedat}
#lincs<-lincs[-which(lincs$response>170),]
lincs<-arrange(lincs, date, line_id, segment)
lincs$panels<-as.numeric(lincs$line_id)
```

```{r salsa1d, cache=TRUE}
initialModel<-glm(response ~ 1 + offset(log(area)), data=lincs, family=quasipoisson)

factorlist<-NULL
varlist<-c('depth', 'month')

salsa1dlist<-list(fitnessMeasure='QAIC', minKnots_1d = c(1,1), maxKnots_1d=c(5,5), startKnots_1d = c(1,1), degree=c(2,2), maxIterations=100, gaps=c(0,0))

salsa1dout<-runSALSA1D_withremoval(initialModel, salsa1dlist, varlist, factorlist, varlist_cyclicSplines = c('month'), splineParams = NULL, datain=lincs, suppress.printout = TRUE)

salsa1dout$bestModel$splineParams<-salsa1dout$splineParams

bestModel1D<-make.gamMRSea(salsa1dout$bestModel, panelid = lincs$panels, splineParams = salsa1dout$splineParams)

```

```{r}
sink()
sink()
```


```{r}
summary(salsa1dout$bestModel)
```

```{r}
anova(salsa1dout$bestModel)
```


```{r partialplots}
par(mfrow=c(1,2))
runPartialPlots(bestModel1D, data = lincs, factorlist.in = factorlist, varlist.in = varlist, showKnots = T)
```


```{r salsa2d, cache=TRUE}
knotgrid<-getKnotgrid(cbind(lincs$x.pos, lincs$y.pos))
distMats<-makeDists(cbind(lincs$x.pos, lincs$y.pos), na.omit(knotgrid))
# choose sequence of radii
r_seq<-getRadiiChoices(8, distMats$dataDist)

salsa2dlist<-list(fitnessMeasure = 'QAIC', knotgrid = knotgrid, knotdim = c(100, 100),  startKnots=6, minKnots=2, maxKnots=20, r_seq=r_seq, gap=0)


salsa2dOutput<-runSALSA2D(bestModel1D, salsa2dlist, d2k=distMats$dataDist, k2k=distMats$knotDist, splineParams=NULL, tol=0, chooserad=F, panels=NULL, suppress.printout=TRUE)

bestModel<-make.gamMRSea(salsa2dOutput$bestModel, panelid = as.numeric(lincs$panels), splineParams = salsa2dOutput$splineParams, varshortnames = varlist, gamMRSea=TRUE)

```

```{r}
save(bestModel, file='D:/lindesay/MarScoPower/finalreportdata/lincsAUKmodel.RData', compress='bzip2')

#load('D:/lindesay/MarScoPower/finalreportdata/lincsAUKmodel.RData')
```

```{r checkmodelpreds}

par(mfrow=c(1,2))
quilt.plot(lincs$x.pos, lincs$y.pos, lincs$response, asp=1, nrow=80, ncol=80)
quilt.plot(lincs$x.pos, lincs$y.pos, fitted(bestModel), asp=1, nrow=80, ncol=80)

```



#### check for correlation:

```{r corcheck, cache=TRUE}
nsim<-500
d<-as.numeric(summary(bestModel)$dispersion)
newdat<-generateNoise(nsim, fitted(bestModel), family='poisson', d=d)

empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat,   model = bestModel, data = lincs, plot=TRUE,   returnDist = TRUE, dots=FALSE)

runs.test(residuals(bestModel, type='pearson'), critvals = empdistribution)
acf(residuals(bestModel, type='pearson'))
```

```{r}
#lincs$panels<-as.numeric(lincs$line_id)
corrs<-getCorrelationMat(lincs$panels, lincs$response, dots=FALSE)
newdatcor<-generateIC(data = lincs, corrs = corrs, panels = 'panels', newdata = newdat, nsim = nsim, dots = FALSE)

```

### check data generation process
```{r}
plotMean(bestModel, newdat)

```

```{r}
plotVariance(bestModel, newdatcor)
```

```{r}
# par(mfrow=c(2,2))
# acf(lincs$response, main='Data')
# acf(newdat[,1], main='sim data')
# acf(residuals(bestModel, type='pearson'), main='original model residuals')
# acf(residuals(update(bestModel, newdat[,1] ~ .), type='pearson'), main='sim model residuals')

par(mfrow=c(2,2))
acf(lincs$response, main='Data')
acf(newdatcor[,10], main='sim data')
acf(residuals(bestModel, type='pearson'), main='original model residuals')
acf(residuals(update(bestModel, newdatcor[,10] ~ .), type='pearson'), main='sim model residuals')
```


```{r}
par(mfrow=c(2,2))
runACF(lincs$panels, model = lincs$response)
runACF(lincs$panels, model = newdat[,1])
runACF(lincs$panels, model = bestModel)
runACF(lincs$panels, model = update(bestModel, newdat[,1]~.))

```


```{r}
par(mfrow=c(2,2))
quilt.plot(lincs$x.pos, lincs$y.pos, lincs$response, main='Original Data')
quilt.plot(lincs$x.pos, lincs$y.pos, fitted(bestModel), main='Fitted Values')
quilt.plot(lincs$x.pos, lincs$y.pos, newdatcor[,1], main='Simulated Data Example')
quilt.plot(lincs$x.pos, lincs$y.pos, apply(newdatcor, 1, mean), main='Mean Simulated Data')

```

```{r}
par(mfrow=c(1,1))
quilt.plot(lincs$x.pos, lincs$y.pos, apply(newdatcor, 1, mean) - fitted(bestModel))
```

# power analysis

### Generate impact data
```{r}
nsim=500
truebeta<-0.5
impdata.auk<-genChangeData(truebeta*100, model = bestModel, data = lincs,panels = "panels")
```

```{r}
t<-group_by(impdata.auk, eventphase)%>%
  summarise(sum=sum(truth), mean=mean(truth), n=n())
t
```

```{r}

bef<-impdata.auk[impdata.auk$eventphase==0,]
aft<-impdata.auk[impdata.auk$eventphase==1,]

spdf1<- SpatialPointsDataFrame( data.frame( x = bef$x.pos , y = bef$y.pos ) , data = data.frame( z = bef$truth) )
e <- extent( spdf1 )
ratio <- ( e@xmax - e@xmin ) / ( e@ymax - e@ymin )
r <- raster( nrows = 60 , ncols = floor( 60 * ratio ) , ext = extent(spdf1) )
rf <- rasterize( spdf1 , r , field = "z" , fun= mean)
rdf1 <- data.frame( rasterToPoints( rf ), evph=0 )   

spdf2<- SpatialPointsDataFrame( data.frame( x = aft$x.pos , y = aft$y.pos ) , data = data.frame( z = aft$truth) )
e <- extent( spdf2 )
ratio <- ( e@xmax - e@xmin ) / ( e@ymax - e@ymin )
r <- raster( nrows = 60 , ncols = floor( 60 * ratio ) , ext = extent(spdf2) )
rf <- rasterize( spdf2 , r , field = "z" , fun= mean)
rdf2 <- data.frame( rasterToPoints( rf ), evph=1 ) 

rdf<-rbind(rdf1, rdf2)
names(rdf)[3]<-'Mean.count'

pct.change<-((rdf$Mean.count[rdf$evph==1] - rdf$Mean.count[rdf$evph==0])/rdf$Mean.count[rdf$evph==0]
)*100

ggplot( NULL ) + geom_raster( data = rdf1 , aes( x , y , fill = pct.change ) ) + scale_fill_gradientn(colours=mypalette, values = breaks,space = "Lab", na.value = "grey50", guide = "colourbar") + theme_bw()

```



```{r}
newdata.auk.imp<-generateNoise(nsim, impdata.auk$truth, family='poisson', d=summary(bestModel)$dispersion)
newdatcor.auk.imp<-generateIC(data = impdata.auk, corrs = rbind(corrs,corrs), panels = 'panels.1', newdata = newdata.auk.imp, nsim = nsim, dots = FALSE)

```

```{r}
bestModel$splineParams[[1]]$dist<-rbind(bestModel$splineParams[[1]]$dist, bestModel$splineParams[[1]]$dist)
auksim_glm<-update(bestModel, newdatcor.auk.imp[,1]~. + eventphase, data=impdata.auk)
auksim_glm$panels<-impdata.auk$panels.1

```


make sure that the independent data is used to get the null distribution
```{r warning=FALSE, message=FALSE}
empdistpower.auk<-getRunsCritVals(n.sim = nsim, simData=newdat.auk.imp, 
                                  model = auksim_glm, data = impdata.auk, plot=FALSE,  returnDist = TRUE, dots=FALSE)
```


```{r}

# make predictions for month 10 - month with highest estimated density (from month partial plot)
predictdata<-rbind(data.frame(pred_grid[,1:3], month=6, area=1, eventphase=0), data.frame(pred_grid[,1:3], month=6, area=1, eventphase=1))
names(predictdata)[1:2]<-c('x.pos', 'y.pos')

g2k<-makeDists(cbind(predictdata$x.pos, predictdata$y.pos), knotcoords = na.omit(bestModel$splineParams[[1]]$knotgrid), knotmat = FALSE)$dataDist


```


```{r aukpower, cache=TRUE}
nsim=100
powerout.auk.oc<-powerSimPll(newdatcor.auk.imp, auksim_glm, empdistpower.auk, nsim=nsim, powercoefid=length(coef(auksim_glm)), predictionGrid=predictdata, g2k=g2k, splineParams=auksim_glm$splineParams, sigdif=TRUE, n.boot=100, nCores = 6)
```

```{r}
save(powerout.auk.oc.50, file='../FinalReportCode/powerout.lincsauk.oc50.RData', compress = 'bzip2')
```


```{r auknull, cache=TRUE}
null.output.auk.oc.50<-pval.coverage.null(newdat.ind = newdata.auk.imp, newdat.corr = NULL, model = auksim_glm, nsim = nsim, powercoefid = length(coef(auksim_glm)))

```

```{r}
save(null.output.auk.oc.50, file='../FinalReportCode/null.output.lincsauk.oc50.RData', compress = 'bzip2')

```



```{r pow50summary}
summary(powerout.auk.oc.50, null.output.auk.oc.50, truebeta=log(truebeta))
```


```{r pow50powerplot}
powerPlot(powerout.auk.oc.50)

```

```{r pow50predplot}
plot.preds(powerout.auk.oc.50)
```

```{r pow50diffsplot}
plot.diffs(powerout.auk.oc.50)
```

```{r pow50sigdiff}
plot.sigdiff(powerout.auk.oc.50, coordinates = predictdata[predictdata$eventphase==0,c('x.pos', 'y.pos')], tailed='two', error.rate = 0.05, gridcell.dim = c(1000,1000))
```

```{r pow50sigdiffsid}
plot.sigdiff(powerout.auk.oc.50, coordinates = predictdata[predictdata$eventphase==0,c('x.pos', 'y.pos')], tailed='two', error.rate = 0.05, adjustment='sidak', gridcell.dim = c(1000,1000))
```

```{r pow50sigdiffbonf}
plot.sigdiff(powerout.auk.oc.50, coordinates = predictdata[predictdata$eventphase==0,c('x.pos', 'y.pos')], tailed='two', error.rate = 0.05, adjustment='bonferroni', gridcell.dim = c(1000,1000))
```


# Power analysis: 25% decline

```{r}
nsim=500
truebeta<-0.75
impdata.auk<-genChangeData(truebeta*100, model = bestModel, data = lincs, panels = "panels")
```


```{r}
t<-group_by(impdata.auk, eventphase)%>%
  summarise(sum=sum(truth), mean=mean(truth), n=n())
t
```


```{r}
newdata.auk.imp<-generateNoise(nsim, impdata.auk$truth, family='poisson', d=d)

newdatcor.auk.imp<-generateIC(data = impdata.auk, corrs = rbind(corrs,corrs), panels = 'panels.1', newdata = newdata.auk.imp, nsim = nsim, dots = FALSE)

```

```{r}
auksim_glm<-update(bestModel, newdata.auk.imp[,1]~. + eventphase, data=impdata.auk)
auksim_glm$panels<-impdata.auk$panels.1
```


make sure that the independent data is used to get the null distribution
```{r warning=FALSE, message=FALSE}
empdistpower.auk<-getRunsCritVals(n.sim = nsim, simData=newdata.auk.imp,
                                  model = auksim_glm, data = impdata.auk, plot=FALSE,  returnDist = TRUE, dots=FALSE)

```


```{r aukpower25, cache=TRUE}
nsim=100
powerout.auk.oc25<-powerSimPll(newdata.auk.imp, auksim_glm, empdistpower.auk, nsim=nsim, powercoefid=length(coef(auksim_glm)), predictionGrid=predictdata, g2k=g2k, splineParams=auksim_glm$splineParams, sigdif=TRUE, n.boot=200, nCores = 6)
```

```{r}
save(powerout.auk.oc25, file='../FinalReportCode/powerout.lincsauk.oc25.RData', compress = 'bzip2')
```


```{r auknull25, cache=TRUE}
null.output.auk.oc25<-pval.coverage.null(newdat.ind = newdata.auk.imp, newdat.corr = NULL, model = auksim_glm, nsim = nsim, powercoefid = length(coef(auksim_glm)))

```

```{r}
save(null.output.auk.oc25, file='../FinalReportCode/null.output.lincsauk.oc25.RData', compress = 'bzip2')

```


```{r}
summary(powerout.auk.oc, null.output.auk.oc, truebeta=truebeta)
```


```{r}
powerPlot(powerout.auk.oc)

```

```{r}
plot.preds(powerout.auk.oc)
```

```{r}
plot.diffs(powerout.auk.oc)
```

```{r}
plot.sigdiff(powerout.auk.oc, coordinates = predictdata[predictdata$eventphase==0,c('x.pos', 'y.pos')], tailed='two', error.rate = 0.05)
```

```{r}
plot.sigdiff(powerout.auk.oc, coordinates = predictdata[predictdata$eventphase==0,c('x.pos', 'y.pos')], tailed='two', error.rate = 0.05, adjustment='sidak')
```

```{r}
plot.sigdiff(powerout.auk.oc, coordinates = predictdata[predictdata$eventphase==0,c('x.pos', 'y.pos')], tailed='two', error.rate = 0.05, adjustment='bonferroni')
```
