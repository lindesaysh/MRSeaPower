---
title: "Runs Test Paper"
author: "Lindesay Scott-Hayward"
date: "`r Sys.Date()`"
output: pdf_document
number_sections: yes
toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment='', warning=FALSE, message = FALSE)
```

# Simulated Data

```{r packages, echo=FALSE}
require(MRSeaPower)
nsim=1000
```

Make some simulated toy data using the following equation:

$$y=\beta_0\ +\ \beta_1X_1$$

where $\beta_0 = 1$ and $\beta_1= 0.3$


```{r simdata}
dat<-makeToyData(200, length.panels=5)
head(dat)
```

## Uncorrelated data 

`r nsim` sets of noisy data are simulated from this truth using a Poisson distribution.

```{r simnoise}
newdat<-generateNoise(nsim, dat$mu, family='poisson', d=1)
```

To test, fit a glm to one of the sets of data.
```{r initglm}
init_glm<-glm(newdat[,1] ~ x, data=dat, family='quasipoisson')
summary(init_glm)
```

Models were fitted to all datasets generated above and the runs test was evaluated for each one.  The distribution of the test statistics is returned.  A plot is also produced, which shows the lower 2.5\% and upper 97.5\% critical values of the empirical distribution (red) and from the Normal ($N(0,1)$) distribution.

```{r critvals, cache=T}
empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                 model = init_glm, data = dat, plot=TRUE, 
                                 returnDist = TRUE)
```

Use the data generated to assess the 5\% error rate for this test when using the Normal distribition or the empirical distribution generated above. 

```{r simpvals, cache=TRUE}
newdat<-generateNoise(nsim, dat$mu, family='poisson', d=1)
ps<-matrix(NA, nrow=nsim, ncol=2)

for(i in 1:nsim){
  sim_glm<-glm(newdat[,i] ~ x , data=dat, family='quasipoisson')
  # find both the empirical and Normal p-values
  ps[i,1]<-runs.test(residuals(sim_glm, type='pearson'), critvals = empdistribution)$p.value
  ps[i,2]<-runs.test(residuals(sim_glm, type='pearson'))$p.value
}
```


```{r}
(length(which(ps[,1]<0.05))/nsim)*100
(length(which(ps[,2]<0.05))/nsim)*100
```

How does this change if we vary the dispersion parameter for the data?

```{r phisim, cache=TRUE}
nphi=seq(1,51, by=5)
errrate<-matrix(NA, nrow=length(nphi), ncol=2)
counter=1
nsim=2000
for(p in nphi){
  newdat<-generateNoise(nsim, dat$mu, family='poisson', d=p)
  # for each change in phi, update the empirical distribution
  empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                   model = init_glm, data = dat, plot=FALSE, 
                                   returnDist = TRUE, dots=FALSE)
  
  ps<-matrix(NA, nrow=nsim, ncol=2)
  for(i in 1:nsim){
    sim_glm<-glm(newdat[,i] ~ x + as.factor(evph), data=dat, family='quasipoisson')
    # find both the empirical and Normal p-values
    ps[i,1]<-runs.test(residuals(sim_glm, type='pearson'), critvals = empdistribution)$p.value
    ps[i,2]<-runs.test(residuals(sim_glm, type='pearson'))$p.value
  }
  
  errrate[counter,1]<-(length(which(ps[,1]<0.05))/nsim)*100
  errrate[counter,2]<-(length(which(ps[,2]<0.05))/nsim)*100
  counter=counter+1
}

```

```{r plotphisim}
plot(nphi, errrate[,1], type='l', col='red', ylim=c(0, range(errrate)[2]), ylab='Error Rate', xlab='Dispersion Parameter')
lines(nphi, errrate[,2], col='blue')
legend(0, 20, legend = c('N(0,1)', 'Empirical'), col = c('blue', 'red'), lty = c(1,1), bty = 'n')
```

## Correlated data 

```{r}
dat<-makeToyData(200, length.panels=5)
head(dat)
```

```{r corsim, cache=TRUE}
nsim=2000
newdat<-generateNoise(nsim, dat$mu, family='poisson', d=1)
rho=seq(0.1, 0.9, by=0.1)
errrate<-matrix(NA, nrow=length(rho), ncol=2)
counter=1

for(r in rho){
  newdatcorr<-generateIC.toy(dat, c(1, r, r^2, r^3, r^4), 'panelid', newdat, ncol(newdat), dots=FALSE)
  
  # for each change in phi, update the empirical distribution
  empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                   model = init_glm, data = dat, plot=FALSE, 
                                   returnDist = TRUE, dots=FALSE)
  
  ps<-matrix(NA, nrow=nsim, ncol=2)
  for(i in 1:nsim){
    sim_glm<-glm(newdatcorr[,i] ~ x , data=dat, family='quasipoisson')
    # find both the empirical and Normal p-values
    ps[i,1]<-runs.test(residuals(sim_glm, type='pearson'), critvals = empdistribution)$p.value
    ps[i,2]<-runs.test(residuals(sim_glm, type='pearson'))$p.value
  }
  
  errrate[counter,1]<-(length(which(ps[,1]<0.05))/nsim)*100
  errrate[counter,2]<-(length(which(ps[,2]<0.05))/nsim)*100
  counter=counter+1
}

```

```{r plotcorsim}
plot(rho, errrate[,1], type='l', col='red', ylim=c(0, range(errrate)[2]), ylab='Error Rate', xlab='Correlation coefficient', main='Dispersion = 1')
lines(rho, errrate[,2], col='blue')
legend(0, 20, legend = c('N(0,1)', 'Empirical'), col = c('blue', 'red'), lty = c(1,1), bty = 'n')
```


```{r corsimphi50, cache=TRUE}
nsim=2000
newdat<-generateNoise(nsim, dat$mu, family='poisson', d=50)
rho=seq(0.1, 0.9, by=0.1)
errrate<-matrix(NA, nrow=length(rho), ncol=2)
counter=1

for(r in rho){
  newdatcorr<-generateIC.toy(dat, c(1, r, r^2, r^3, r^4), 'panelid', newdat, ncol(newdat), dots=FALSE)
  
  # for each change in phi, update the empirical distribution
  empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                   model = init_glm, data = dat, plot=FALSE, 
                                   returnDist = TRUE, dots=FALSE)
  
  ps<-matrix(NA, nrow=nsim, ncol=2)
  for(i in 1:nsim){
    sim_glm<-glm(newdatcorr[,i] ~ x , data=dat, family='quasipoisson')
    # find both the empirical and Normal p-values
    ps[i,1]<-runs.test(residuals(sim_glm, type='pearson'), critvals = empdistribution)$p.value
    ps[i,2]<-runs.test(residuals(sim_glm, type='pearson'))$p.value
  }
  
  errrate[counter,1]<-(length(which(ps[,1]<0.05))/nsim)*100
  errrate[counter,2]<-(length(which(ps[,2]<0.05))/nsim)*100
  counter=counter+1
}

```

```{r plotcorsimphi50}
plot(rho, errrate[,1], type='l', col='red', ylim=c(0, range(errrate)[2]), xlim=c(0.1,1), ylab='Error Rate', xlab='Correlation coefficient', main='Dispersion = 50')
lines(rho, errrate[,2], col='blue')
legend(0.7, 30, legend = c('N(0,1)', 'Empirical'), col = c('blue', 'red'), lty = c(1,1), bty = 'n')
```

As expected, when the dispersion in the data is high, there is a greater discrepancy between the N(0,1) and empirical distributions.


## What does all this mean for power analysis?

If data are assumed to be correlated, then a correlation structure is chosen and GEE - type model fitted.  If the independent working correlation structure is specified, then robust standard errors are used for inference.  Does this machinery still work when there is actually no correlation present in the data?

Question:

1. Are robust standard errors the same as raw standard errors when no correlation is present?
2. What happens when a blocking structure is chosen that is not necessary.  i.e. does the answer to question 1 vary with differing block structures?
3. Is the power to detect change affected by using robust standard errors when not necessary?

Make data but add an impact. Here we repeat the data but have a 50\% decline in the response for the second set.

### 50\% decline, $\phi = 50$
```{r}
datimp<-makeToyData(200, length.panels=5, changecoef.link = log(0.5))
head(datimp)
```

Generate independent noisy data with a high dispersion, e.g. $\phi = 50$
```{r}
nsim=2000
newdat<-generateNoise(nsim, datimp$mu, family='poisson', d=50)
```

```{r}
init_impglm<-glm(newdat[,1] ~ x + as.factor(evph), data=datimp, family='quasipoisson')
summary(init_impglm)
```

Get the empirical distribution critical values:
```{r}
empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                 model = init_impglm, data = datimp, plot=FALSE, 
                                 returnDist = TRUE, dots=FALSE)
```

```{r pow50imp}
runspowsim_out<-runsPowerSim(newdat, init_impglm, empdistribution, nsim, powercoefid = 3)
```

```{r}
apply(runspowsim_out$rawrob, 2, sum)/nsim

(length(which(runspowsim_out$imppvals[,1]<=0.05))/nsim)*100
(length(which(runspowsim_out$imppvals[,2]<=0.05))/nsim)*100

```

### 25\% decline, $\phi = 50$
```{r pow25imp, cache=TRUE, echo=FALSE}
datimp<-makeToyData(200, length.panels=5, changecoef.link = log(0.75))
init_impglm<-update(init_impglm, .~., data=datimp)

newdat<-generateNoise(nsim, datimp$mu, family='poisson', d=50)

empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                 model = init_impglm, data = datimp, plot=FALSE, 
                                 returnDist = TRUE, dots=FALSE)

runspowsim_out<-runsPowerSim(newdat, init_impglm, empdistribution, nsim, powercoefid = 3)

apply(runspowsim_out$rawrob, 2, sum)/nsim

(length(which(runspowsim_out$imppvals[,1]<=0.05))/nsim)*100
(length(which(runspowsim_out$imppvals[,2]<=0.05))/nsim)*100

```

### 0\% decline, $\phi = 50$
```{r pow0imp, cache=TRUE, echo=FALSE}
datimp<-makeToyData(200, length.panels=5, changecoef.link = log(1))
init_impglm<-update(init_impglm, .~., data=datimp)

newdat<-generateNoise(nsim, datimp$mu, family='poisson', d=50)

empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                 model = init_impglm, data = datimp, plot=FALSE, 
                                 returnDist = TRUE, dots=FALSE)

runspowsim_out<-runsPowerSim(newdat, init_impglm, empdistribution, nsim, powercoefid = 3)

apply(runspowsim_out$rawrob, 2, sum)/nsim

(length(which(runspowsim_out$imppvals[,1]<=0.05))/nsim)*100
(length(which(runspowsim_out$imppvals[,2]<=0.05))/nsim)*100

```

It seems that when the Normal distribution is used to test for correlation, consistently the power to detect change is higher than when the empirical distribution is used to choose which standard errors to use.

Test: Repeat for 50\% decline to get a range of power values.  Check to see if the discrepancy is consistent.

### 50\% decline, $\phi = 50$, multiruns
```{r pow50impmulti, cache=TRUE, echo=FALSE}
datimp<-makeToyData(200, length.panels=5, changecoef.link = log(0.5))
init_impglm<-update(init_impglm, .~., data=datimp)
nsim=2000
ssim=100
power=runspower=matrix(NA, nrow=ssim, ncol=2)
for(s in 1:ssim){
  newdat<-generateNoise(nsim, datimp$mu, family='poisson', d=50)
  
  empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                   model = init_impglm, data = datimp, plot=FALSE, 
                                   returnDist = TRUE, dots=FALSE)
  
  runspowsim_out<-runsPowerSim(newdat, init_impglm, empdistribution, nsim, powercoefid = 3)
  
  runspower[s,]<-apply(runspowsim_out$rawrob, 2, sum)/nsim
  
  power[s,1]<-(length(which(runspowsim_out$imppvals[,1]<=0.05))/nsim)*100
  power[s,2]<-(length(which(runspowsim_out$imppvals[,2]<=0.05))/nsim)*100
  
}

```

```{r }
wilcox.test(x = runspower[,1], runspower[,2], paired = T)
wilcox.test(x = power[,1], power[,2], paired = T)
```
```{r}
apply(power, 2, mean)
apply(runspower, 2, mean)
```

Statistically we have a significant difference between the power calculated from raw/robust s.e. but the real world significance in this toy example is minimal. The mean difference is one percentage point (with raw giving a higher power). 


### 25\% decline, $\phi = 50$, multiruns
```{r pow25impmulti, cache=TRUE, echo=FALSE}
datimp<-makeToyData(200, length.panels=5, changecoef.link = log(0.75))
init_impglm<-update(init_impglm, .~., data=datimp)
nsim=2000
ssim=100
power=runspower=matrix(NA, nrow=ssim, ncol=2)
for(s in 1:ssim){
  newdat<-generateNoise(nsim, datimp$mu, family='poisson', d=50)
  
  empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                   model = init_impglm, data = datimp, plot=FALSE, 
                                   returnDist = TRUE, dots=FALSE)
  
  runspowsim_out<-runsPowerSim(newdat, init_impglm, empdistribution, nsim, powercoefid = 3)
  
  runspower[s,]<-apply(runspowsim_out$rawrob, 2, sum)/nsim
  
  power[s,1]<-(length(which(runspowsim_out$imppvals[,1]<=0.05))/nsim)*100
  power[s,2]<-(length(which(runspowsim_out$imppvals[,2]<=0.05))/nsim)*100
}

wilcox.test(x = runspower[,1], runspower[,2], paired = T)
wilcox.test(x = power[,1], power[,2], paired = T)
apply(power, 2, mean)
apply(runspower, 2, mean)
```

## Toy data with smaller mean

The Falls of Warness data has a very small mean (1.01) compared with the toy data used so far.  Here we reduce the mean of the toy data inline with that seen in the Falls of Warness data to see if we can replicate results
```{r}
datlow<-makeToyData(200, length.panels=5, b0=-2)
head(datlow)
mean(datlow$mu)
```


```{r lowmeaninitglm}
init_glm<-glm(newdat[,1] ~ x, data=datlow, family='quasipoisson')
summary(init_glm)
```

```{r lowmeanphisim, cache=TRUE}
nphi=seq(1,51, by=5)
errrate<-matrix(NA, nrow=length(nphi), ncol=2)
counter=1
nsim=2000
for(p in nphi){
  newdat<-generateNoise(nsim, datlow$mu, family='poisson', d=p)
  # for each change in phi, update the empirical distribution
  empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                   model = init_glm, data = datlow, plot=FALSE, 
                                   returnDist = TRUE, dots=FALSE)
  
  ps<-matrix(NA, nrow=nsim, ncol=2)
  for(i in 1:nsim){
    sim_glm<-glm(newdat[,i] ~ x + as.factor(evph), data=datlow,
                 family='quasipoisson')
    # find both the empirical and Normal p-values
    ps[i,1]<-runs.test(residuals(sim_glm, type='pearson'), critvals = empdistribution)$p.value
    ps[i,2]<-runs.test(residuals(sim_glm, type='pearson'))$p.value
  }
  
  errrate[counter,1]<-(length(which(ps[,1]<0.05))/nsim)*100
  errrate[counter,2]<-(length(which(ps[,2]<0.05))/nsim)*100
  counter=counter+1
}
```

```{r lowmeanphiplot}
plot(nphi, errrate[,1], type='l', col='red', ylim=c(0, range(errrate)[2]), ylab='Error Rate', xlab='Dispersion Parameter')
lines(nphi, errrate[,2], col='blue')
legend(35, 40, legend = c('N(0,1)', 'Empirical'), col = c('blue', 'red'), lty = c(1,1), bty = 'n')
```

### 25\% decline, $\phi = 50$, multiruns

```{r lowmeanpow25impmultid50, cache=TRUE, echo=FALSE}
datimplow<-makeToyData(200, length.panels=5, changecoef.link = log(0.75), b0=-2)
init_impglm<-glm(newdat[,1] ~ x + as.factor(evph), data=datimplow, family='quasipoisson')
nsim=2000
ssim=100
power=runspower=matrix(NA, nrow=ssim, ncol=2)
for(s in 1:ssim){
  newdat<-generateNoise(nsim, datimplow$mu, family='poisson', d=50)
  
  empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                   model = init_impglm, data = datimplow,
                                   plot=FALSE, returnDist = TRUE, dots=FALSE)
  
  runspowsim_out<-runsPowerSim(newdat, init_impglm, empdistribution, nsim, powercoefid = 3)
  
  runspower[s,]<-apply(runspowsim_out$rawrob, 2, sum)/nsim
  
  power[s,1]<-(length(which(runspowsim_out$imppvals[,1]<=0.05))/nsim)*100
  power[s,2]<-(length(which(runspowsim_out$imppvals[,2]<=0.05))/nsim)*100
}

wilcox.test(x = runspower[,1], runspower[,2], paired = T)
wilcox.test(x = power[,1], power[,2], paired = T)
apply(power, 2, mean)
apply(runspower, 2, mean)
```

### 25\% decline, $\phi = 1$, multiruns

```{r lowmeanpow25impmultid1, cache=TRUE, echo=FALSE}
datimplow<-makeToyData(200, length.panels=5, changecoef.link = log(0.75), b0=-2)
init_impglm<-glm(newdat[,1] ~ x + as.factor(evph), data=datimplow, family='quasipoisson')
nsim=2000
ssim=100
power=runspower=matrix(NA, nrow=ssim, ncol=2)
for(s in 1:ssim){
  newdat<-generateNoise(nsim, datimplow$mu, family='poisson', d=1)
  
  empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                   model = init_impglm, data = datimplow,
                                   plot=FALSE, returnDist = TRUE, dots=FALSE)
  
  runspowsim_out<-runsPowerSim(newdat, init_impglm, empdistribution, nsim, powercoefid = 3)
  
  runspower[s,]<-apply(runspowsim_out$rawrob, 2, sum)/nsim
  
  power[s,1]<-(length(which(runspowsim_out$imppvals[,1]<=0.05))/nsim)*100
  power[s,2]<-(length(which(runspowsim_out$imppvals[,2]<=0.05))/nsim)*100
}

wilcox.test(x = runspower[,1], runspower[,2], paired = T)
wilcox.test(x = power[,1], power[,2], paired = T)
apply(power, 2, mean)
apply(runspower, 2, mean)
```


# Real Data: Falls of Warness

```{r fow, echo=FALSE}
data(fowshco)
```

```{r fowinitglm}
init_glm<-glm(response ~  TideState + WindStrength + SeaState + SimpPrecipitation + CloudCover, data=dat, family=quasipoisson)
```

```{r fownoise}
nsim=500
newdat<-generateNoise(nsim, fitted(init_glm), family='poisson', d=1)
```
`r nsim` sets of noisy data are simulated from this truth using a Poisson distribution.

To test, fit a glm to one of the sets of data.
```{r fowglm}
fowsim_glm<-glm(newdat[,1] ~  TideState + WindStrength + SeaState + SimpPrecipitation + CloudCover, data=dat, family=quasipoisson)
summary(fowsim_glm)
```

## Runs Test Check
Models were fitted to all datasets generated above and the runs test was evaluated for each one.  The distribution of the test statistics is returned.  A plot is also produced, which shows the lower 2.5\% and upper 97.5\% critical values of the empirical distribution (red) and from the Normal ($N(0,1)$) distribution.

```{r critvalsfow, cache=T}
empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                 model = fowsim_glm, data = dat, plot=TRUE, 
                                 returnDist = TRUE)
```

Use the data generated to assess the 5\% error rate for this test when using the Normal distribition or the empirical distribution generated above. 

```{r simpvalsfow, cache=TRUE}
newdat<-generateNoise(nsim, fitted(init_glm), family='poisson', d=1)
ps<-matrix(NA, nrow=nsim, ncol=2)

for(i in 1:nsim){
  sim_glm<-update(fowsim_glm, newdat[,i]~.)
  # find both the empirical and Normal p-values
  ps[i,1]<-runs.test(residuals(sim_glm, type='pearson'), critvals = empdistribution)$p.value
  ps[i,2]<-runs.test(residuals(sim_glm, type='pearson'))$p.value
}
```


```{r}
(length(which(ps[,1]<0.05))/nsim)*100
(length(which(ps[,2]<0.05))/nsim)*100
```

How does this change if we vary the dispersion parameter for the data?

```{r phisimfow, cache=TRUE}
nphi=seq(1,51, by=5)
errrate<-matrix(NA, nrow=length(nphi), ncol=2)
counter=1
nsim=500
for(p in nphi){
  newdat<-generateNoise(nsim, fitted(init_glm), family='poisson', d=p)
  # for each change in phi, update the empirical distribution
  empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                   model = init_glm, data = dat, plot=FALSE, 
                                   returnDist = TRUE, dots=FALSE)
  
  ps<-matrix(NA, nrow=nsim, ncol=2)
  for(i in 1:nsim){
    sim_glm<-update(fowsim_glm, newdat[,i]~.)
    # find both the empirical and Normal p-values
    ps[i,1]<-runs.test(residuals(sim_glm, type='pearson'), critvals = empdistribution)$p.value
    ps[i,2]<-runs.test(residuals(sim_glm, type='pearson'))$p.value
  }
  
  errrate[counter,1]<-(length(which(ps[,1]<0.05))/nsim)*100
  errrate[counter,2]<-(length(which(ps[,2]<0.05))/nsim)*100
  counter=counter+1
}

```

```{r plotphisimfow}
plot(nphi, errrate[,1], type='l', col='red', ylim=c(0, range(errrate)[2]), ylab='Error Rate', xlab='Dispersion Parameter')
lines(nphi, errrate[,2], col='blue')
legend(0, 30, legend = c('N(0,1)', 'Empirical'), col = c('blue', 'red'), lty = c(1,1), bty = 'n')
```

## Asessing the effect on Power

### 0% decline, dispersion = 50
```{r fowpowersim0dec}
nsim=200
impdata<-genOverallchangeData(log(1), init_glm, data = dat)
newdat<-generateNoise(nsim, impdata$truth, family='poisson', d=50)
fowsim_glm<-glm(newdat[,1] ~  TideState + WindStrength + SeaState + SimpPrecipitation + CloudCover + as.factor(eventphase), data=impdata, family=quasipoisson)
empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                 model = fowsim_glm, data = impdata, plot=TRUE, 
                                 returnDist = TRUE, dots = FALSE)
```

```{r FOWrunspower0d50, cache=TRUE}
runspowsim_out<-runsPowerSim(newdat, fowsim_glm, empdistribution, nsim, powercoefid = length(coef(fowsim_glm)))

```

```{r}
apply(runspowsim_out$rawrob, 2, sum)/nsim

(length(which(runspowsim_out$imppvals[,1]<=0.05))/nsim)*100
(length(which(runspowsim_out$imppvals[,2]<=0.05))/nsim)*100
```

#### Multiple runs of power test: 0% decline, dispersion=50

```{r FOWpow0impmulti, cache=TRUE, echo=FALSE}
nsim=200
ssim=100
power=runspower=matrix(NA, nrow=ssim, ncol=2)
for(s in 1:ssim){
  newdat<-generateNoise(nsim, impdata$truth, family='poisson', d=50)
  
  empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                   model = fowsim_glm, data = impdata, plot=FALSE, 
                                   returnDist = TRUE, dots=FALSE)
  
  runspowsim_out<-runsPowerSim(newdat, fowsim_glm, empdistribution, nsim, powercoefid = length(coef(fowsim_glm)))
  
  runspower[s,]<-apply(runspowsim_out$rawrob, 2, sum)/nsim
  
  power[s,1]<-(length(which(runspowsim_out$imppvals[,1]<=0.05))/nsim)*100
  power[s,2]<-(length(which(runspowsim_out$imppvals[,2]<=0.05))/nsim)*100
  
}

```

```{r FOWpow0impmultiwilcox}
wilcox.test(x = runspower[,1], runspower[,2], paired = T)
wilcox.test(x = power[,1], power[,2], paired = T)
```

```{r FOWpow0impmultiout}
apply(power, 2, mean)
apply(runspower, 2, mean)
```

### 25% decline, dispersion = 50
```{r fowpowersim25dec}
nsim=200
impdata<-genOverallchangeData(log(0.75), init_glm, data = dat)
newdat<-generateNoise(nsim, impdata$truth, family='poisson', d=50)
fowsim_glm<-glm(newdat[,1] ~  TideState + WindStrength + SeaState + SimpPrecipitation + CloudCover + as.factor(eventphase), data=impdata, family=quasipoisson)
empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                 model = fowsim_glm, data = impdata, plot=TRUE, 
                                 returnDist = TRUE, dots = FALSE)
```

```{r FOWrunspower25d50, cache=TRUE}
runspowsim_out<-runsPowerSim(newdat, fowsim_glm, empdistribution, nsim, powercoefid = length(coef(fowsim_glm)))

```

```{r}
apply(runspowsim_out$rawrob, 2, sum)/nsim

(length(which(runspowsim_out$imppvals[,1]<=0.05))/nsim)*100
(length(which(runspowsim_out$imppvals[,2]<=0.05))/nsim)*100
```

#### Multiple runs of power test: 25% decline, dispersion=50 

```{r FOWpow25impmulti, cache=TRUE, echo=FALSE}
nsim=200
ssim=100
power=runspower=matrix(NA, nrow=ssim, ncol=2)
for(s in 1:ssim){
  newdat<-generateNoise(nsim, impdata$truth, family='poisson', d=50)
  
  empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                   model = fowsim_glm, data = impdata, plot=FALSE, 
                                   returnDist = TRUE, dots=FALSE)
  
  runspowsim_out<-runsPowerSim(newdat, fowsim_glm, empdistribution, nsim, powercoefid = length(coef(fowsim_glm)))
  
  runspower[s,]<-apply(runspowsim_out$rawrob, 2, sum)/nsim
  
  power[s,1]<-(length(which(runspowsim_out$imppvals[,1]<=0.05))/nsim)*100
  power[s,2]<-(length(which(runspowsim_out$imppvals[,2]<=0.05))/nsim)*100
  
}

```

```{r FOWpow25impmultiwilcox}
wilcox.test(x = runspower[,1], runspower[,2], paired = T)
wilcox.test(x = power[,1], power[,2], paired = T)
```

```{r FOWpow25impmultiout}
apply(power, 2, mean)
apply(runspower, 2, mean)
```


#### Multiple runs of power test: 10% decline, dispersion=50 

```{r FOWpow10impdata, cache=TRUE, echo=FALSE}
nsim=200
impdata<-genOverallchangeData(log(0.9), init_glm, data = dat)
newdat<-generateNoise(nsim, impdata$truth, family='poisson', d=50)
fowsim_glm<-glm(newdat[,1] ~  TideState + WindStrength + SeaState + SimpPrecipitation + CloudCover + as.factor(eventphase), data=impdata, family=quasipoisson)

```

```{r FOWpow10impmulti, cache=TRUE, echo=FALSE}
ssim=10
nsim=50
power=runspower=matrix(NA, nrow=ssim, ncol=2)
for(s in 1:ssim){
  newdat<-generateNoise(nsim, impdata$truth, family='poisson', d=50)
  
  empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                   model = fowsim_glm, data = impdata, plot=FALSE, 
                                   returnDist = TRUE, dots=FALSE)
  
  runspowsim_out<-runsPowerSim(newdat, fowsim_glm, empdistribution, nsim, powercoefid = length(coef(fowsim_glm)))
  
  runspower[s,]<-apply(runspowsim_out$rawrob, 2, sum)/nsim
  
  power[s,1]<-(length(which(runspowsim_out$imppvals[,1]<=0.05))/nsim)*100
  power[s,2]<-(length(which(runspowsim_out$imppvals[,2]<=0.05))/nsim)*100
  
}

```

```{r FOWpow10impmultiwilcox}
wilcox.test(x = runspower[,1], runspower[,2], paired = T)
wilcox.test(x = power[,1], power[,2], paired = T)
```

```{r FOWpow10impmultiout}
apply(power, 2, mean)
apply(runspower, 2, mean)
```

#### Multiple runs of power test: 10% decline, dispersion=80 

```{r FOWpow10impdata80, cache=TRUE, echo=FALSE}
nsim=10
impdata<-genOverallchangeData(log(0.9), init_glm, data = dat)
newdat<-generateNoise(nsim, impdata$truth, family='poisson', d=80)
fowsim_glm<-glm(newdat[,1] ~  TideState + WindStrength + SeaState + SimpPrecipitation + CloudCover + as.factor(eventphase), data=impdata, family=quasipoisson)

```

```{r FOWpow10impmulti80, cache=TRUE, echo=FALSE}
ssim=10
nsim=50
power=runspower=matrix(NA, nrow=ssim, ncol=2)
for(s in 1:ssim){
  newdat<-generateNoise(nsim, impdata$truth, family='poisson', d=80)
  
  empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                   model = fowsim_glm, data = impdata, plot=FALSE, 
                                   returnDist = TRUE, dots=FALSE)
  
  runspowsim_out<-runsPowerSim(newdat, fowsim_glm, empdistribution, nsim, powercoefid = length(coef(fowsim_glm)))
  
  runspower[s,]<-apply(runspowsim_out$rawrob, 2, sum)/nsim
  
  power[s,1]<-(length(which(runspowsim_out$imppvals[,1]<=0.05))/nsim)*100
  power[s,2]<-(length(which(runspowsim_out$imppvals[,2]<=0.05))/nsim)*100
  
}

```

```{r FOWpow10impmultiwilcox80}
wilcox.test(x = runspower[,1], runspower[,2], paired = T)
wilcox.test(x = power[,1], power[,2], paired = T)
```

```{r FOWpow10impmultiout80}
apply(power, 2, mean)
apply(runspower, 2, mean)
```
