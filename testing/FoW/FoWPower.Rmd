---
title: "Fall of Warness"
author: "Lindesay Scott-Hayward"
date: "26 August 2016"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig=TRUE, dev='png', warning=FALSE, message=FALSE, comment='')
```
# Real Data: Fall of Warness

```{r fow, echo=FALSE}
#devtools::load_all(pkg = '../../../../Packages/MRSea package/MRSea')
devtools::load_all(pkg = '../../../MRSea/MRSea')
devtools::load_all(pkg = '../../../MRSeaPower')
data(fowshco)
```

```{r, fig.cap='Plot of the data with average counts per grid cell.'}
require(fields)
quilt.plot(dat$x.pos, dat$y.pos, dat$response, nrow=18, ncol=14, asp=1)

```



### Fit Initial Model
```{r fowinitglm}
init_glm<-glm(response ~  as.factor(TideState) + WindStrength + SeaState + SimpPrecipitation + CloudCover + Depth + offset(log(areatime)), data=dat, family=quasipoisson)

init_glm<-make.gamMRSea(init_glm, panelid=dat$panels)
```


### Runs Test Check

Data generated under the null hypothesis of the runs test; independence and with no change induced at this stage.

```{r fownoise}
nsim<-500
d<-as.numeric(summary(init_glm)$dispersion)
newdat<-generateNoise(nsim, fitted(init_glm), family='poisson', d=d)
```

`r nsim` sets of noisy data are simulated from the model using an overdispersed Poisson distribution where $$\hat{\phi} = $$ `r round(summary(init_glm)$dispersion)`.

```{r critvalsfow, cache=T, fig.cap='Figure showing the distribution of test statistics from a runs test. The red lines show the lower 2.5% and upper 97.5% critical values of the empirical distribution and the blue lines are from the Normal ($N(0,1)$) distribution.'}
empdistribution<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                 model = init_glm, data = dat, plot=TRUE, 
                                 returnDist = TRUE, dots=FALSE)
```

Evaluate the runs test using the empirical distribution to determine if the data are independent
```{r runsacffow}
runs.test(residuals(init_glm, type='pearson'), critvals = empdistribution)
acf(residuals(init_glm, type='pearson'))
```

The residuals are not considered independent so for the power analysis, the data will be generated as correlated.

### Data Generation

Data are generated with no change but with the same dispersion and correlation as the original data so that the data generation process can be checked.

```{r cordatfow, cache=TRUE}
corrs<-getCorrelationMat(dat$newbidNum, dat$response, dots=FALSE)
newdatcor<-generateIC(data = dat, corrs = corrs, panels = 'blockid', newdata = newdat, nsim = nsim, dots = FALSE)
```

Are the generated data consistent with the original data?

#### Mean
```{r meanplot, fig.cap='Histogram of the mean of the simulated data, with the red line representing the mean of the original data.'}
hist(apply(newdatcor, 2, mean), main='', xlab='mean(response)')
abline(v=mean(dat$response), col='red', lwd=2, lty=3)
```

In this case the mean of the original data sits inside the distribution of simulated means. 

#### Variance
```{r varplot, fig.cap='Histogram of the variance of the simulated data, with the red line representing the variance of the original data.'}
hist(apply(newdatcor, 2, var), main='', xlab='var(response)')
abline(v=var(dat$response), col='red', lwd=2, lty=3)
var(dat$response)
```

Unfortunately the variance of the simulated data is lower than that of the original data ($$\sigma^2 = $$ ```r round(var(dat$response), 3)```).  This could be due to the overly simplistic model being unable to return the variability seen in the data.  This model is then used to simulate from.

#### Correlation

```{r acfplot}
par(mfrow=c(1,2))
acf(dat$response, main='Data')
acf(newdatcor[,50], main='Sim Data')
```

The correlation seen in the data matches well with the example shown from the simulated data.  This indicates the IC method is working well.

#### Check the dispersion parameter

```{r}
fowsim_glm<-update(init_glm, newdatcor[,1] ~ .)
summary(fowsim_glm)$dispersion
```


#### Data spatial distribution

```{r datadistribution, fig.cap='Figure showing the spatial distribution of the original data, the fitted values from the model and two examples of the simulated data.'}
require(fields)
par(mfrow=c(2,2))
quilt.plot(dat$x.pos, dat$y.pos, dat$response, main='Original Data', nrow=18, ncol=14, asp=1)
quilt.plot(dat$x.pos, dat$y.pos, fitted(init_glm), main='Fitted Values', nrow=18, ncol=14, asp=1)
quilt.plot(dat$x.pos, dat$y.pos, newdatcor[,1], main='Simulated Data A', nrow=18, ncol=14, asp=1)
quilt.plot(dat$x.pos, dat$y.pos, newdatcor[,10], main='Simulated Data B', nrow=18, ncol=14, asp=1)
```

These plots show that the spatial distribution of the data is well represented by the simulated data. 

### Power Analysis

Now that we know we can generate data that represents the original fairly well, we now generate data for the power analysis with a change imposed of **50\%**; a 50\% decline in animal numbers post event.

First the change is imposed on the data, then the noise is added (in-line with the dispersion seen in the initial model) and finally the correlation. 

```{r powerdatgen, cache=TRUE}
nsim=500
impdata<-genOverallchangeData(log(0.5), init_glm, data = dat, panels = 'newbidNum')
newdat<-generateNoise(nsim, impdata$truth, family='poisson', d=d)
newdatcor<-generateIC(data = impdata, corrs = rbind(corrs, corrs), panels = 'panels', newdata = newdat, nsim = nsim, dots = FALSE)
```

Update the initial model to include the eventphase term, indicating overall change. This model forms the foundation of the power analysis to follow.

```{r}
fowsim_glm<-update(fowsim_glm, .~. + eventphase, data=impdata)
```

The new values for the empirical distribution of the runs test are estimated using the noisy but un-correlated simulated data. This is differenct to the distribution generated earlier as we have another term in the model (eventphase).

```{r empdistpower, cache=TRUE}
# make sure that the independent data is used to get the null distribution
empdistpower<-getRunsCritVals(n.sim = nsim, simData=newdat, 
                                 model = fowsim_glm, data = impdata, plot=TRUE, 
                                 returnDist = TRUE, dots=FALSE)
```


```{r, powerouta, cache=TRUE, eval=FALSE, echo=FALSE}
runspowsim_out<-runsPowerSim(newdatcor, fowsim_glm, empdistpower, nsim, powercoefid = length(coef(fowsim_glm)))
  
apply(runspowsim_out$rawrob, 2, sum)/nsim
  
(length(which(runspowsim_out$imppvals[,1]<=0.05))/nsim)*100
(length(which(runspowsim_out$imppvals[,2]<=0.05))/nsim)*100

```

If an offset is present in the model, the area of each gridcell should be provided when setting up the prediction grid so that an accurate estimate of the abundance pre and post event can be made at the outputs stage. 

```{r predgridsetup, cache=TRUE}
data("fowshco.grid")
predictdata<-rbind(data.frame(fowshco.grid, TideState=1, WindStrength=0, SeaState=0, SimpPrecipitation='SHOWERS', CloudCover=0, areatime=fowshco.grid$Area, eventphase=0), data.frame(fowshco.grid, TideState=1, WindStrength=0, SeaState=0, SimpPrecipitation='SHOWERS', CloudCover=0,areatime=fowshco.grid$Area, eventphase=1))
```

```{r poweroutfow, cache=TRUE, dependson=c('predgridsetup', 'powerdatagen')}
nsim=100
powerout<-powerSimOverallChange(newdatcor, fowsim_glm, empdistpower, nsim=nsim, powercoefid=length(coef(fowsim_glm)), predictionGrid=predictdata, g2k=NULL, splineParams=NULL, sigdif=TRUE, n.boot=500, impact.loc=c(510700, 6555700))
```

# Power Outputs:

To calculate the summary, the values for certain parameters are given under the null hypothesis of 'no change'.  If these parameters are not provided, then the summary will not show the comparisons (see below)

### Summary output

```{r}
summary(powerout, truebeta=log(0.5))
```

In order to assess the summary calculations, we estimate the null parameters to provide the full summary. 

```{r nulloutput, cache=TRUE}
null.output<-pval.coverage.null(newdat.ind = newdat, newdat.corr = newdatcor, model = fowsim_glm, nsim = 500, powercoefid = length(coef(fowsim_glm)))
```

```{r}
summary(powerout, null.output, truebeta=log(0.5))
```

We expect to see the null power to be 5\%, indicating a 5\% error rate for inclusion of the eventphase term when the data do not contain any change.  We also expect that the coverage for the null coefficient is 95\%.  This indicates that 5\% of the time, the confidence intervals for the eventphase coefficient did not include the truth (0; no change).


### Proportion of significant differences:
```{r sigdiff.ind, fig.cap='Figure showing the proportion of simulations which showed a significant difference (post event - pre event) in a given grid cell. Significance at the 5% level was determined by comparing the estimated difference in a given cell to the distribution of differences in that cell under the null hypothesis of no-change.'}
plotdata<-plot.sigdiff(powerout, predictdata[predictdata$eventphase==0,c('x.pos', 'y.pos')], tailed='two', error.rate = 0.05, family=FALSE)
plotdata
```

```{r sigdiff.fam, fig.cap='Figure showing the proportion of simulations which showed a significant difference (post event - pre event) in a given grid cell. Significance at the family 5% level was determined by using the Sidak adjustment.'}
plotdata<-plot.sigdiff(powerout, predictdata[predictdata$eventphase==0,c('x.pos', 'y.pos')], tailed='two', error.rate = 0.05, family=TRUE)
plotdata
```

### Distance to event site plot

```{r disttoimp, fig.cap='Figure showing the effect of the event on animal numbers with distance from the event site; post event - pre event.  The confidence intervals are 95% bootstrap intervals.'}
d2impPlot<-plot.d2imp(powerout, pct.diff=FALSE)
d2impPlot
```


```{r disttoimppct, fig.cap='Figure showing the effect of the event on animal numbers with distance from the event site; post event - pre event.  The confidence intervals are 95% bootstrap intervals.'}
d2impPlot<-plot.d2imp(powerout, pct.diff = TRUE)
d2impPlot
```

```{r, echo=FALSE, eval=FALSE}
lazyLoad(filebase = 'FoWPower_cache/docx/poweroutfow_9b61b0f606b3436a5ec4644d2949daec')
```

